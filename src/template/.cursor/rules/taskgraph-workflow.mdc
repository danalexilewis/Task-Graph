---
description: Task-Graph plan creation, review protocol, import, and execution loop
alwaysApply: true
---

# Task-Graph Workflow

## Orientation

Before executing any plan, run `pnpm tg status` to see what's outstanding. **Multi-agent:** Check "Active work" for other agents' tasks; avoid overlapping on the same files/area. If overlap is detected, use `tg note <taskId> --msg "..."` to signal and pick a different task. If there are stale `doing` tasks or forgotten `todo` tasks for completed work, clean them up first (see Recovery below).

## Plan Creation and Review

- **Plans** live in `plans/<date>_<name>.md` in Cursor format (YAML frontmatter with `name`, `overview`, `todos`). Filenames use the convention `yy-mm-dd_the_file_name.md` (see plan-authoring.mdc).
- After creating a plan: summarize it, then **pause** and ask for review. Do not import or execute until the user responds.

### Interpreting User Response

| User says                                              | Action                                       |
| ------------------------------------------------------ | -------------------------------------------- |
| proceed, go ahead, execute, run it, let's do it        | Import plan to taskgraph, then execute tasks |
| just add the tasks, add to taskgraph only              | Import only; do not execute                  |
| thanks, that's good, looks good, ok, don't do anything | Do nothing (acknowledgement only)            |

### Import Command

```bash
pnpm tg import plans/<file> --plan "<Plan Name>" --format cursor
```

## Execution Loop (per task — MANDATORY)

For EACH task, follow ALL steps in order. Never skip start, never defer done.

1. `pnpm tg start <taskId> --agent <name>` — **MUST** run before doing any work (pass `--agent` when multiple agents may be active)
2. `pnpm tg context <taskId>` — Read the output: domain doc path (`docs/<domain>.md`), skill guide path (`docs/skills/<skill>.md`), and related done tasks. Load those docs before coding.
3. Do the work (stay within scope)
4. `pnpm tg done <taskId> --evidence "..."` — **MUST** run immediately after work is complete

Evidence should include: tests run, commands, git hashes.

### Sub-agent dispatch (optional)

You may execute tasks by **dispatching fast sub-agents** instead of doing every step yourself: use `.cursor/rules/subagent-dispatch.mdc` for parallel batch execution (multiple unblocked tasks) or sequential implementer → reviewer. Prefer sub-agents when tasks are well-scoped with clear intent; use direct execution (steps 1–4 above) for exploratory or ambiguous work.

### Multi-task discipline

When executing N tasks in sequence, complete the full start→work→done cycle for each one individually. Never batch-skip transitions.

### Plan completion

After marking the last task in a plan as done, run:

```bash
pnpm tg export markdown --plan <planId> --out plans/<date>_<name>.md
```

Use a filename that follows the convention (`yy-mm-dd_the_file_name.md`). This updates the plan file with final statuses, closing the round-trip.

## Recovery (out-of-sync tasks)

If work is already done but the task is still `todo` or `doing` in taskgraph:

- **Task is `todo`**: `pnpm tg done <taskId> --force --evidence "completed previously"`
- **Task is `doing`**: `pnpm tg done <taskId> --evidence "completed previously"`

Run `pnpm tg status` after cleanup to verify.

## When Blocked

- `pnpm tg block <taskId> --on <blockerId> --reason "..."`
- If blocker does not exist: create a new task with owner=human, then block on it.
